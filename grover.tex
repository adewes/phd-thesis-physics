
\chapter{Running the Grover Search Algorithm} \label{chapter:grover_algorithm}

This chapter describes an experimental implementation of the so-called {\it Grover search algorithm} with our two-qubit quantum processor. The first section provides a short introduction of the algorithm and motivate the interest in realizing it. The following sections then discuss the details of the experimental realization of the algorithm. We show the results that we obtained and compare the algorithm fidelity and run time to that of an equivalent, classical algorithm. Finally, we will analyze all relevant unitary and non-unitary error sources relevant to our experiment and provide a quantitative error model of our implementation of the algorithm.

\section{Introduction \& Motivation}

Search algorithms are of great importance in many domains of mathematics and computer science. One such search problem that often arises and which will be discussed in the following sections can be formulated in simple terms as follows:

\smallskip

Assume that we have a search space $\begin{mathcal}S\end{mathcal}$ that consists of a finite number $N$ of states $s \in \begin{mathcal}S\end{mathcal}$. The solution to our search problem corresponds to a subset of $M$ states of the search space $\begin{mathcal}T\end{mathcal} \subset \begin{mathcal}S\end{mathcal}$. We can then define a search function $\Or(s):\begin{mathcal}S\end{mathcal}\to \{0,1\}$ that discriminates between states that solve the search problem and states that don't, such that $\Or(s) = 1$ for $s \in \begin{mathcal}T\end{mathcal}$ and $\Or(s) = 0$ otherwise. In accordance with the general convention in the research literature on the Grover search algorithm, we will  often refer to this search function as the {\it Oracle function} or (in a quantum-mechanical context) as the {\it Oracle operator}.

\smallskip

Using this definition of the search problem, the goal of a search algorithm is to find all states $t\in\begin{mathcal}S\end{mathcal}$ for which $\Or(t) = 1$. In the following sections, for the sake of simplicity we assume that the solution set $\begin{mathcal}T\end{mathcal}$ contains only one single state $t$. This special case can be generalized to cases where more than one solution to the search problem exists (see e.g. \cite{nielsen_quantum_2000,mermin_quantum_2007} for a detailed review of the general-case Grover search algorithm)

\smallskip

The first step in order to solve a search problem of the kind described above using classical or quantum computation is to map the problem to a form suitable for solution by a digital (quantum) computer. For this, we first number and encode the $N$ input states $i \in \begin{mathcal}S\end{mathcal}$ in binary form as $i=(b^i_l,\hdots,b^i_0)_B$, where $l$ is the length of the binary register able to hold all $N$ input states. With this definition, it is then trivial to find a mathematical representation of $\Or$ that operates on a binary input register. 

\smallskip

Using these assumptions and definitions, it can be shown that the most efficient classical search algorithm for solving the search problem above will use $\begin{mathcal}O\end{mathcal}(N)$ calls of the function $\Or$ to find all solutions $t$ of the search problem. Assuming that the time to evaluate the function $\Or$ is far superior to the time needed to perform any other operation during the search algorithm, the time needed for calling the function $\Or$ $n$-times corresponds approximately to the run time of the whole search algorithm.

\smallskip

Amazingly, in 1997, Lov Grover found a quantum algorithm that could solve this search problem with only $\begin{mathcal}O\end{mathcal}(\sqrt{N})$ calls to the function $\Or$ \citep{Grover_Quantum_1997}. His algorithm achieves this by repeatedly calling a quantum-mechanical implementation of the function $\Or$, starting from a highly superposed qubit register $\sum\limits_i^N \ket{i}$ and applying a special operator to the resulting output state afterwards. The individual steps of his algorithm are straightforward and are given as follows:

\begin{enumerate}
 \item Initialize a qubit register to the state $\ket{\psi} = \ket{0}$ (corresponding to a binary input state $\ket{0000\hdots0_B}$)
 \item Apply the generalized Hadamard operation to the qubit register, producing a fully superposed quantum state $$\ket{\psi} = \frac{1}{\sqrt{N}}\sum\limits_{i=0}^{N-1} \ket{i}$$
 \item Repeat the following sequence $\begin{mathcal}O\end{mathcal}(\sqrt{N})$ times:
 \subitem a) Apply the {\it Oracle operator} $\ket{i}\to (-1)^{\Or(i)}\ket{i}$ to the state $\ket{\psi}$
 \subitem b) Apply the so-called {\it diffusion operator} $\ket{i} \to -\ket{i}+\frac{2}{N}\sum\limits_{j=0}^{N-1}\ket{j}$ to $\ket{\psi}$
	\item Measure the state of the quantum register in the computational basis $\ket{i}$.
\end{enumerate}

Please note that for the description above we have enumerated the states of the qubit register from $\ket{0}$ to $\ket{N-1}$. The Grover algorithm makes use of quantum parallelism to solve the search problem $\begin{mathcal}O\end{mathcal}(\sqrt{N})$ times faster than the most efficient classical algorithm. To understand better the strategy it uses, the different steps of the algorithm can be rephrased in the following, more general way:

\begin{itemize}
\item First, the algorithm creates a fully superposed quantum state which contains all possible solutions to the search problem at once. The amplitudes and phases of each individual state are all equal in the beginning.
\item Then, it applies the Oracle operator to this superposed state. The effect of the Oracle is to turn the phase of the states $t$ by an angle $\pi$ for which $\Or(t)=1$. As will be shown later, such an Oracle operator can be implemented in a straightforward way for any classical search function.
\item In the next step, it applies a diffusion operator to the quantum state which transfers a fraction of the amplitude from states with zero phase to the states with $\pi$ phase, increasing thus the amplitude of the latter. In this process, the phases of all states get also turned back to zero, allowing the algorithm to repeat the sequence above.
\item Repeating these two operations increases each time the amplitude of the states that correspond to a solution of the search problem until the amplitudes of all the other states vanish. After that point, the process reverses and the amplitude is transferred back to the original states. It is therefore crucial to stop the repetition sequence given above after the right number of iterations.
\end{itemize}

By implementing the search function as a quantum operator, the Grover algorithm is able to evaluate it in one single call for all possible input states. This so-called {\it quantum parallelism} provides the basis for the speed-up of the search in comparison to a classical algorithm. However, being able to encode the result of the search function in the phase of a multi-qubit state does not directly translate to a speed advantage since it is usually very hard to extract this phase information from the quantum state. Indeed, to extract the values of all phases from an $N$-qubit state, it would be necessary to perform $\begin{mathcal}O(2^N)\end{mathcal}$ measurements on an ensemble of such identically prepared quantum states. However, extracting the amplitudes from such a state takes only $\begin{mathcal}O\end{mathcal}(N)$ measurements, that in addition can usually be carried out in parallel. It is for this reason that the Grover algorithm uses an operator that transforms the information encoded in the phases of the qubits to an information encoded in their amplitude. However, since the conversion between phase to amplitude information through the application of an unitary operator is limited by certain physical constraints, the algorithm needs to repeat the encode-and-transfer sequence described above $\begin{mathcal}O(\sqrt{N})\end{mathcal}$ times. \cite{lloyd_quantum_1999,meyer_sophisticated_2000,lanyon_experimental_2008,ahn_information_2000,ding_review_2007,linden_good_2001,braunstein_speed-up_2002}

\smallskip

To analyze further the constraints and principles of the algorithm, we will discuss a more detailed derivation of it starting from the Schrödinger equation and we will also explain what limits the efficiency of the phase-to-amplitude conversion in the algorithm.

\subsection{Deriving the Grover Algorithm from Schrödinger's Equation}


An interesting derivation of the Grover algorithm starting from Schrödinger's equation has been detailed by Grover himself in a seminal paper \citep{grover_schrodingers_2001} and shall be briefly rediscussed here since it sheds light on the basic principles on which the algorithm is based. The derivation begins by considering a quantum system governed by Schrödinger's equation, which can be written as (setting $\hbar = 1$ for clarity)
%
\begin{equation}
-i\frac{\partial}{\partial t}\psi(x,t) = \frac{\partial^2}{\partial x^2}\psi(x,t)-V(x)\psi(x,t) \label{eq:grover_derivation}
\end{equation}
%

\begin{wrapfigure}{r}{6cm}
\vspace{-1cm}
\includegraphics[width=5.2cm]{"./material/papers/grover/grover_derivation_schroedinger"}
\caption{A wave function $\psi(x)$ and potential $V(x)$ defined on a grid of points $x_1,\hdots,x_N$.}
\label{fig:GroverDerivationSchroedinger}
\end{wrapfigure}


Here $\psi(x,t)$ describes the wave-function and $V$ is a time-independent potential. Let us assume that the potential $V(x)$ is shaped as in fig. \ref{fig:GroverDerivationSchroedinger}, i.e. possessing a global minimum of energy. When one initializes the system to a state $\psi_0(x,t_0)$ and lets it evolve for a given time, $\psi(x,t)$ will be attracted by the minimum of potential energy and ``fall into it'' much like a classical particle in such a potential would\footnote{of course, since there is no dissipation, the state will not come to rest at the minimum point of energy but rather oscillate around it conserving its total potential and kinetic energy}. We might thus ask if we can encode the solution to a search problem as a point of minimum energy $x_0$ of a potential $V(x)$, take an initial state $\psi_0(x,t_0)$ and let it evolve into a state that has a high probability around $x_0$, thereby solving the search problem. To answer this question, it is first necessary to discretize the wave function $\psi(x,t)$ such that it can represent the search problem stated in the last section, and which is defined over a finite number of states. In the most simple case, we can use a regular grid of points $x_i$ with a spacing $\Delta x$ for this, as shown in fig. \ref{fig:GroverDerivationSchroedinger}b. Discretizing the time evolution of eq. \ref{eq:grover_derivation} in steps $\Delta t$ as well and defining $\epsilon = \Delta t/\Delta x^2$, we obtain a new equation of the form
%
\begin{equation}
-\frac{\psi_i^{t+\Delta t}-\psi_x^{t}}{\Delta t} = \frac{\psi_{i+1}^t+\psi_{i-1}^t-2\psi_x^t}{\Delta x^2} -V(x_i)\psi_i^t
\end{equation}
%
where we have written $\psi(x_i,t)=\psi_i^t$. For a circular grid with $N$ points we can write this equation in matrix form as
%
\begin{equation}
\vec{\psi}^{t+\Delta t} = S^{\Delta t}  \cdot \vec{\psi}^t
\end{equation}
%
with $S$ being a state transition matrix of the form
%
\begin{equation}
S^{\Delta t} = \left(
	\begin{array}{ccccc}
		1-2i\epsilon-iV(x_1)\Delta t & i\epsilon & 0 & \hdots &  i\epsilon \\
		i \epsilon & 1-2i\epsilon -iV(x_2)\Delta t & i\epsilon & \hdots & 0 \\
		0 & i\epsilon & \ddots & & \vdots \\
		\vdots & & & \ddots  & \vdots \\
		i \epsilon & 0 & \hdots & i\epsilon & 1 - 2i\epsilon -iV(x_N)\Delta t
	\end{array}
 \right) \label{eq:grover_iteration_matrix}
\end{equation}
%
For infinitesimal times $\Delta t$ we can separate the effect of the potential $V(x)$ on the wave function from the spatial dispersion $\propto i\epsilon$ by writing $S^{\Delta t} \approx D\cdot R$ with 
%
\begin{eqnarray}
D & = & \left( 
		\begin{array}{cccccc}
		1-2i \epsilon & i\epsilon & 0 & 0 & \hdots & i\epsilon \\
		i \epsilon & 1 - 2i \epsilon & i \epsilon & 0 & \hdots & 0 \\
		\hdots & \ddots & & & & \vdots \\
		i \epsilon & 0 & 0 &  \hdots & i\epsilon & 1-2i \epsilon \\
		\end{array}
	\right)
\end{eqnarray}
%
and 
%
\begin{eqnarray}
R & = & \left( \begin{array}{ccccc}
	e^{-i V(x_1) \Delta t} & 0 & \hdots & 0 \\
	0 & e^{-i V (x_2) \Delta t} & \hdots & 0 \\
	0 & \hdots & & 0 & e^{-i V (x_N) \Delta t} \\
	\end{array}
	\right)
\end{eqnarray}
%
This approximation is correct to order $\begin{mathcal}O\end{mathcal}(\epsilon)$ up to an irrelevant renormalization factor. Now, we can repeatedly apply the matrix product $D\cdot R$ to the wave function to obtain its state after a given finite time $t$ by writing
%
\begin{equation}
\vec{\psi}^{t_0+t} = \left(\prod\limits_{i = 1}^{t/\Delta t} D\cdot R\right)\cdot \vec{\psi}^{t} \label{eq:trotter_evolution}
\end{equation}
%
This technique of splitting up the full evolution operator into a product of two or more non-commuting operators that are applied repeatedly to the wave function to obtain its state after a finite time is sometimes referred to as {\it Trotterization} -- in reference to the so-called {\it Lie-Trotter formula} on which it is based -- and on which relies digital quantum simulation \citep{lloyd_universal_1996,lanyon_universal_2011}.

\smallskip

As can be seen in eq. (\ref{eq:trotter_evolution}), the evolution of the wave function at infinitesimal times is governed by two processes: The interaction with the potential $V$ and a diffusion process that mixes different spatial parts of the wave function with each other. The operator $D$ resembles a Markov diffusion process since each row and column of the matrix sums up to unity, whereas $R$ changes the phase of each element of the wave function as a function of the local potential seen by it. If we apply $R$ to a fully superposed initial state of the form $\psi_i = 1$ (omitting the normalization factor for clarity) and assume that $V_i = 0$ for $i \ne j$ and $V_j \Delta t = \pi/2$ (the potential thus encoding a search function with $\Or(j)=1$ and $\Or(i)=0$ for $i\ne j$), the element $\psi_j$ will get turned according to $\psi_j \to i\psi_j $, whereas all other elements $\psi_i$ will remain unchanged. Applying the operator $D$ to the resulting state will transform $\psi_j$ according to $\psi_j \to \psi_j(i+2\epsilon(1+i))$ with a corresponding amplitude $\sqrt{1+4\epsilon+\begin{mathcal}O\end{mathcal}(\epsilon^2)}$ and the adjacent states $\psi_{j\pm 1}$ according to $\psi_{j\pm 1} \to \psi_{j\pm 1}(1-\epsilon(1+i))$ with an amplitude $\sqrt{1-2\epsilon +\begin{mathcal}O\end{mathcal}(\epsilon^2)}$. Hence there is a transfer of amplitude between the state whose phase has been turned and its neighboring states. If we reset the phases of all the $\psi_i$ to zero afterwards, we can iterate the application of $D\cdot R$ until all of the amplitude has been transferred to the element $\psi_j$ which corresponds to a solution to the search problem. This is, in essence, exactly what the Grover algorithm does, the only difference being that it replaces the matrix $D$ with an unitary matrix that maximizes the amplitude transfer to the states solving the search problem, thereby speeding up the algorithm. As stated before, the efficiency with which the algorithm can transfer amplitude between different states is limited by physical constraints. In the next section, we will therefore discuss exactly what limits this efficiency and which unitary diffusion matrix one should choose to maximize it.

\subsubsection{Efficiency of Quantum Searching}

It is interesting to ask which is the maximum amount of amplitude that can be transferred in a single step of the Grover search algorithm and which matrix $D$ should be chosen to maximize this transfer. To answer this question and derive the ideal diffusion matrix, we will assume first that, without loss of generality, the matrix $R$ which encodes the value of the search function $\Or$ in the quantum state of the qubit register can be written as
%
\begin{eqnarray}
R & = & \begin{mathrm}I\end{mathrm}-2\sum\limits_{j=0}^{N-1} \Or(j)\ket{j}\bra{j} \label{eq:GroverOracleFunction}
\end{eqnarray}
%
This operator will flip the sign of all states for which $\Or(j) = 1$. Now, the next step consists in finding a diffusion or state transfer matrix which will maximize the amplitude transfer to states marked by the Oracle operator above and which will also reset the phases of the quantum register to zero afterwards, such that we might apply the Oracle operator to the resulting state again. In the most general case, such a state transfer matrix will have the form
%
\begin{equation}
D_c = \left(	
	\begin{array}{ccccc}
		b & a & a & \hdots & a \\
		a & b & a & \hdots & a \\
		\vdots & & \ddots &  &\vdots \\
		a & & \hdots & a & b \\
	\end{array}
\right)
\end{equation}
%
Here, we assume that all non-diagonal elements of the matrix are equal, which is well justified since we have no knowledge of the structure of the search space of the problem and therefore want to treat all basis states equally during the phase-to-amplitude conversion. Furthermore, since both the initial quantum state and the Oracle operator as given by eq. (\ref{eq:GroverOracleFunction}) contain only real numbers and we demand that the quantum state after applying $D_c$ may contain only positive real numbers as well it is easy to show that $a,b$ must be real numbers. Finally, the unitarity of quantum operators demands that $D_c^\dagger D_c = \begin{mathrm}I\end{mathrm}$, which for the matrix above is equivalent to the two conditions
%
\begin{eqnarray}
 1 & = & b^2+(N-1)a^2 \\
0 & = & 2ab +(N-2)a^2
\end{eqnarray}
%
Solving these two equations for $a,b$ yields the trivial solution $b = \pm 1$, $a = 0$ and the more interesting one $b = \pm(1-2/N)$, $a=\mp 2/N$. As can be checked easily, the solution $b = 1-2/N$, $a = 2/N$ results in a maximum amplitude transfer from states $\ket{i}$ for which $\Or(i)=0$ to states $\ket{j}$ for which $\Or(j)=1$. Thus the ideal diffusion matrix to be used in the Grover algorithm is given as
%
\begin{equation}
D = \left( \begin{array}{ccccc}
	-1+2/N & 2/N & 2/N & \hdots & 2/N \\
	2/N & -1 + 2/N & 2/N & \hdots & 2/N \\
	\vdots & & \ddots &  & \vdots \\
	2/N & 2/N & 2/N & \hdots & -1 + 2/N \\ 
	\end{array} \right) \label{eq:GroverDiffusionOperator}
\end{equation}
%
This matrix, together with an Oracle operator $R$ as given by eq. (\ref{eq:GroverOracleFunction}) will yield the maximum amplitude transfer from states not solving the search problem to states that solve it. Repeating the application of $D\cdot R$ on an initially fully superposed quantum state for $\begin{mathcal}O\end{mathcal}(\sqrt{N})$ times will transform the input state to a state containing only the solutions of the search problem.

\subsection{Implementation \& Comparability to Classical Algorithms}

In the following sections we discuss a two-qubit implementation of the Grover search algorithm that we implemented in this work. To be able to compare the Grover algorithm as outlined here to a classical version solving the same search problem, we will now discuss another variant of the algorithm that uses an ancilla qubit to encode the result of the search function. This implementation will make it possible to devise a classical algorithm that can be directly compared to the quantum algorithm. 

\subsection{Ancilla-based Implementation of the Algorithm}

The implementation of the Grover search algorithm as outlined above encodes the value of the search function $\Or$ directly in the phase of the input state supplied to this function. This makes it hard to compare the algorithm to a classical search algorithm which operates on a binary input state and, in general, cannot encode the result of the search function directly in this state. It is therefore useful to formulate a version of the Grover algorithm where the Oracle function does not directly encode the marked state in the input qubit register but rather uses an ancilla qubit to store the result of calling $\Or$. Such a representation of the algorithm, although of little practical relevance, is very useful since it allows us to directly compare the quantum algorithm to a classical counterpart implemented using reversible logic gates, thus making it possible to benchmark the quantum algorithm and provide an estimation of the quantum speed-up that can be achieved.

\begin{figure}[ht!]
	\centering
		\includegraphics[width=\textwidth]{./material/papers/grover/different_oracle_implementations}
	\caption[]{a)Definition of the NOT logic gate used in the diagrams. b) Two-qubit ancilla-based implementation of the Oracle function $\Or$. The state of the third bit get flipped if the search function $\Or(i)=1$ for the given input state $i$. c) An example of an ancilla-based search function that returns a true value for the input state $00$.}
	\label{fig:GroverOracleImplementations}
\end{figure}

Exemplary implementations of ancilla-based search functions $\Or$ implemented using reversible (quantum) gates are shown in fig. \ref{fig:GroverOracleImplementations} for the two-qubit case. There, a two-qubit Tofolli gate in combination with several single-qubit NOT gates (that can be easily implemented as single-qubit $X_{\pi}$ rotations) is used to flip the state of an ancilla-qubit conditionally on the input state of the gate. Using a similar approach, any arbitrary classical search function $\Or$ that can be implemented with a set of universal reversible logic gates (e.g. the Toffoli gate and the NOT gate) can be directly mapped to a corresponding quantum operator that works on quantum-mechanical input states and implements the classical search function.

\begin{figure}[ht!]
	\centering
		\includegraphics[width=1\textwidth]{./material/papers/grover/quantum_algorithm_full}
	\caption[Full version of an ancilla-based implementation of the two-qubit Grover search algorithm]{A full version of an ancilla-based implementation of the two-qubit Grover search algorithm. The algorithm works on a two-qubit input state and flips the state of a control qubit for one of the four possible input states in accordance to an unknown Oracle function. It then applies a 3-qubit control-phase operation of that maps $\ket{xy1}\to -\ket{xy1}$, $\ket{xy0}\to\ket{xy0}$ to encode the state of the control qubit directly in the two input qubits and then uses a diffusion operator to determine the state which has been marked by the Oracle function.}
	\label{fig:GroverAlgorithmFullSchematic}
\end{figure}

\smallskip

Now, to use the Grover algorithm with such an ancilla-based quantum Oracle, it is necessary to re-encode the result of the Oracle in the qubit input state. Fig. \ref{fig:GroverAlgorithmFullSchematic} shows a version of the two-qubit Grover algorithm that achieves exactly this by using a three-qubit control-not (CNOT) gate $C$ of the form
%
\begin{equation}
C = \mathrm{I}^{n\otimes n}-2\sum\limits_{ij} \ket{ij1}\bra{ij1}
\end{equation}
%
After the re-encoding of the result, the ancilla qubit is not needed during the remainder of the algorithm but must not be read out before the algorithm terminates. A discussion of possible realizations of the ancilla-based Oracle operator can also be found in \citep{mermin_quantum_2007}.

\subsection{Comparison to a Classical Algorithm}

\begin{figure}[ht!]
	\centering
		\includegraphics[width=1.0\textwidth]{"./material/papers/grover/classical_reversible_algorithm"}
	\caption{Classical reversible implementation of a search algorithm on a two-bit input register. An exemplary Oracle function can be implemented using two single-bit NOT operations and a Toffoli gate. R designates the generation of a random binary value at the beginning of the algorithm. If the Oracle does not yield the correct answer, the test state is incremented. The average success probability of the algorithm is 50 \%.}
	\label{fig:GroverClassicalReversibleAlgorithm}
\end{figure}

In order to quantify the speed-up achieved by a quantum algorithm it is necessary to map the problem it solves to an equivalent problem that can be solved by a classical algorithm. For the Grover algorithm, this is the search problem that we discussed in the first section of this chapter. Using the reversible, ancilla-based implementation of the search function that was introduced in the last section we can directly formulate a classical algorithm that solves the same problem as the Grover algorithm and compare the run time of the two. Since the two-qubit Grover algorithm evaluates the search function $\Or$ only once it is interesting to ask what would be the success probability of an equivalent classical algorithm that calls $\Or$ once and returns an estimate of the state solving the search problem afterwards. Such an algorithm is shown in fig. \ref{fig:GroverClassicalReversibleAlgorithm} and it achieves a success probability of 50 \% by evaluating once the function $\Or$ for a randomly generated two-bit input value $r$ and returning $r$ if it found $\Or(r)=1$ or $r+1(\mathrm{mod}\;4)$ otherwise. The 50 \% success rate of this algorithm provides a benchmark against which we will measure the speed-up of our implementation of the Grover algorithm.

\smallskip

Alternatively, we can also compare the success probability of the quantum algorithm with either a simple classical ``query'' algorithm or a ``query-and-guess'' algorithm, plotting the success probability of either of them as a function of the number of calls to the Oracle function $\Or$. This makes it possible to compare the performance of the quantum algorithm to the classical ones for an arbitrary number of calls $n$ to $\Or$. Such a comparison will be made later in this chapter when reviewing the experimental data obtained for our implementation of the Grover algorithm.

\section{Experimental Implementation}

\begin{figure}[h!]
	\centering
		\includegraphics[width=0.8\textwidth]{./material/papers/grover/grover_algorithm}
	\caption[Schematic of our implementation of the Grover search algorithm]{Schematic of our implementation of the Grover search algorithm. The algorithm consists in generating a fully superposed input state, applying the Oracle function to it and analyzing the resulting state by applying the Diffusion transform to it and reading out the value of the qubit register afterwards.}
	\label{fig:GroverAlgorithmSchematic}
\end{figure}

We implement a compiled version of the two-qubit Grover algorithm using our two-qubit quantum processor. The gate sequence of the algorithm is shown in fig. \ref{fig:GroverAlgorithmSchematic} and consists of two $i\mathrm{SWAP}$ gates and six single-qubit gates applied to an initial state $\ket{00}$. Here, the first $i\mathrm{SWAP}$ gate together with the two single-qubit $Z_{\pm \pi}$ rotations implement the Oracle function $f(x)$ as given by eq. (\ref{eq:GroverOracleFunction}), where the signs of the rotation operations determines the state which is marked by the Oracle. This state can be either $\ket{00}$ (corresponding to a $Z^I_{-\pi/2}\cdot Z^{II}_{-\pi/2}$ rotation), $\ket{01}$ ($Z^I_{-\pi/2}\cdot Z^{II}_{\pi/2}$), $\ket{10}$ ($Z^I_{\pi/2}\cdot Z^{II}_{-\pi/2}$) or $\ket{11}$ ($Z^I_{\pi/2}\cdot Z^{II}_{\pi/2}$). After the encoding, the second $i\mathrm{SWAP}$ operation together with the following $X^I_{\pi/2}\cdot X^{II}_{\pi/2}$ single-qubit operations implement the diffusion operator as given by eq. (\ref{eq:GroverDiffusionOperator}). The final step of the algorithm consists in reading out the two-qubit register.

\subsection{Pulse Sequence}

To implement the gate sequence described above, we need to realize a sequence of microwave and flux pulses which perform the individual quantum gates of the sequence. To eliminate possible gate errors, we perform a series of calibration measurements before to tune-up the individual single- and two-qubit gates needed for the algorithm, as explained in chapter \ref{chapter:processor_characterization}. In addition, we run individual parts of the algorithm successively and perform quantum state tomography to characterize the state of the quantum register after each step of the algorithm, optimizing the gate operations applied to the qubit in order to maximize the fidelity of the measured states in respect to the ideal ones. Fig. \ref{fig:GroverPulseSequence} shows an experimental pulse sequence for the Grover algorithm with an Oracle operator marking the state $\ket{00}$. Shown are the frequencies of the two qubits during the run time of the algorithm and the microwave drive and readout pulses applied to them.

\begin{figure}[h!]
	\centering
		\includegraphics[width=1.\textwidth]{./material/papers/grover/figures/grover_algorithm_pulse_sequence}
	\caption[Pulse sequence used for implementing the Grover search algorithm]{The pulse sequence used to realize the two-qubit Grover quantum search algorithm. First, a $Y_{\pi/2}$ pulse is applied to each qubit to produce the fully superposed state $1/2(\ket{00}+\ket{01}+\ket{10}+\ket{11})$. Then, an $i\mathrm{SWAP}$ gate is applied, followed by a $Z_{\pm \pi /2}$ gate on each qubit, which combined correspond to the application of the Oracle function. The resulting state is then analyzed using another $i\mathrm{SWAP}$ gate and two $X_{\pi/2}$ gates to extract the state that has been marked by the oracle function. Optionally, a $Y^{12}_{\pi}$ pulse is used on each qubit to increase the readout fidelity.}
	\label{fig:GroverPulseSequence}
\end{figure}

\section{Results}

Here we discuss the results obtained when running the Grover search algorithm with our two-qubit processor. In the first section we will analyze the quantum state of the qubit register during the algorithm by performing quantum state tomography. In the second section we will present and discuss the single-run results obtained in our experiment.

\subsection{State Tomography of the Quantum Register}

\begin{figure}[ht!]
	\centering
		\includegraphics[width=1.\textwidth]{"./data/ct5/2011_04_21 - grover and tomo/good_data/grover algorithm - summary"}
	\caption[Quantum state tomographies at different steps during the Grover search algorithm and single-run outcome probabilities]{Quantum state tomographies at steps 1-4 of the Grover search algorithm, as indicated in fig. \ref{fig:GroverPulseSequence}. The density matrices show the experimentally measured states in color and the theoretical states in black. For each state, the trace fidelity as given by eq. (\ref{eq:quantum_trace_fidelity}) is shown above the density matrix.}
	\label{fig:GroverAlgorithmExperimentalResults}
\end{figure}

Fig. \ref{fig:GroverAlgorithmExperimentalResults} shows the experimentally measured density matrices of the two-qubit register when running the Grover search algorithm for the four possible Oracle functions. For each of those four cases, density matrices were measured at the steps 1-4 of the Grover algorithm, as indicated in fig. \ref{fig:GroverAlgorithmSchematic}. The black outlined circles in the density matrices represent the ideal states and the solid circles represent the measured ones. The trace fidelities of all states with respect to the ideal states are noted above each density matrix. As can be seen, the fidelity diminishes as a function of the run time of the algorithm due to dephasing and relaxation of the qubit register, as we will discuss later. The state fidelities for the final output states of the algorithm are given as $68\%$ for the $\ket{00}$, $64\%$ for the $\ket{01}$, $61\%$ for the $\ket{10}$ and $65\%$ for the $\ket{11}$ Oracle functions.

\subsection{Single Run Results}

\begin{figure}[ht!]
	\centering
		\includegraphics[width=1.\textwidth]{"./data/ct5/2011_04_21 - grover and tomo/good_data/grover algorithm - single run probabilities"}
		\caption[Single-run success probabilities of the Grover search algorithm]{The single-run success probabilities of our implementation of the Grover search algorithm. Shown are the averaged probabilities for the four possible Oracle functions. The red bars correspond to measured values, the blue ones to expected probabilities calculated using the reconstructed density matrices after the final step of the algorithm and the measured two-qubit readout matrix. The dashed line indicates the average success probability of a classical query-and-guess algorithm for comparison.}
	\label{fig:GroverSingleShotResults}
\end{figure}
The experimental state tomographies discussed in the last section show that we are able to implement the Grover search algorithm with adequate fidelity using our two-qubit processor. However, the analysis of the two-qubit register by quantum state tomography at the end of the algorithm does not prove that we can achieve real quantum speed-up with our processor. For this, it is necessary to directly read out the state of the qubit register at the end of the algorithm {\it without} performing any kind of error correction afterwards. By looking at this ``raw'' outcome data and generating statistics over many single runs of the processor we can quantify the success rate and the fidelity of the algorithm we implemented. The results of such measurements that we performed for the four possible Oracle functions are shown in fig. \ref{fig:GroverSingleShotResults}. Besides the single-run probabilities for all four Oracle functions, the diagram shows for comparison the expected outcome probabilities calculated based on the quantum state tomographies discussed above and the readout matrix of the two-qubit processor, as shown in fig. \ref{fig:GroverReadoutMatrix}. As can be seen, the agreement between the measured and calculated probabilities is rather good. The dashed line in the diagrams corresponds to the success probability of a classical single-step ``query-and-guess'' algorithm as described above, which is bound to 50 \% and provides the benchmark against which we measure the quantum speed-up in this system. As can be seen, our implementation of the Grover search algorithm outperforms such a a classical search algorithm for all four Oracle functions, if only by a small margin.


\section{Algorithm Fidelity}

We can define the average fidelity of the algorithm in a single run, which corresponds to the conditional probability of finding the correct state $\ket{i}$ given a certain Oracle function $\Or_i$.  Table \ref{tab:Probabilities-for-obtaining} shows these single-run probabilities along with the so-called {\it user fidelities}, which are
%
\begin{equation}
f_{ab} = p(\ket{ab}|ab) = \frac{p(ab |\ket{ab})}{\sum\limits_{uv}p(uv|\ket{uv})} 
\end{equation}
%
, where $p(ab|\ket{ab})$ is the conditional probability of obtaining the search result $ab$ given the Oracle operator $\ket{ab}$. The user fidelity is complementary to the average fidelity and correspond to the conditional probability of having found the correct state given a certain measured state, averaged over all possible Oracle functions. For all four Oracles, both the single-run and user fidelities are $> 50 \%$, hence demonstrating quantum speed-up in comparison with a classical query-and-guess algorithm, as will be discussed below.

\begin{table}[H]
\begin{centering}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline 
$ab$/$|uv\rangle$ & $\left|00\right\rangle $ & $\left|01\right\rangle $ & $\left|10\right\rangle $ & $\left|11\right\rangle $ & $\sum$ & $f_{ab}$\tabularnewline
\hline
\hline 
00 & \textcolor{red}{0.666} & 0.192 & 0.188 & 0.122 & 1.168 & 57.0 \%\tabularnewline
\hline 
01 & 0.127 & \textcolor{red}{0.554} & 0.071 & 0.122 & 0.874 & 63.4 \%\tabularnewline
\hline 
10 & 0.128 & 0.106 & \textcolor{red}{0.615} & 0.239 & 1.088 & 56.5 \%\tabularnewline
\hline 
11 & 0.079 & 0.148 & 0.126 & \textcolor{red}{0.517} & 0.870 & 59.4 \%\tabularnewline
\hline
\end{tabular}
\par\end{centering}

\caption{\label{tab:Probabilities-for-obtaining}Conditional probabilities
$p_{ab/|uv\rangle}$ and user fidelities $f_{ab}$ for all
possible outcomes $ab$ for our implementation of Grover's algorithm.}

\end{table}

\section{Comparison to a Classical Search Algorithm}

\begin{figure}[h!]
	\centering
	\includegraphics[width=1\textwidth]{"./material/mathematica/comparision_grover_classical"}
	\caption[]{Success probability of our implementation of the Grover search algorithm, plotted against the number of single runs of the algorithm $n$. For comparison we show the success probabilities of a classical query and a classical query-and-guess search algorithm as a function of $n$.}
	\label{fig:comparison_grover_classical}
\end{figure}

As discussed above, we can compare the success probability of our implementation of the Grover search algorithm to different classical algorithm in order to quantify the quantum speed-up that we achieve. When repeatedly running the quantum search algorithm we can define the success probability as the probability of obtaining the right answer to the search problems within $n$ single runs, which is given as
%
\begin{equation}
p_s(n) = \sum\limits_{i=1}^n (1-p_s)^{i-1}p_s
\end{equation}
%
Here, $p_s$ is the single-run success probability of the algorithm. We can plot $p_s(n)$ as a function of the runs of the algorithm and compare it with different classical algorithms. Fig. \ref{fig:comparison_grover_classical} shows such a comparison for our implementation of the Grover search algorithm. Besides the single-run probabilities of the quantum algorithm, we plot the success probability of a classical query search algorithm and a classical query-and-guess algorithm as a function of the Oracle calls $n$ for comparison. The difference between the query and the query-and-guess algorithm is that the former does not return a result if it does not find the solution to the search problem after a number of $n$ calls, whereas the latter takes an ''educated guess`` at the right state even if it did not obtain it directly by calling the Oracle function $n$ times. Hence the statistical success probability of the query-and-guess-algorithm is larger than that of the simple query algorithm, although this effect is negligible for large search spaces $N\gg 4$.

As can be seen, our implementation of the Grover search algorithm beats the classical query algorithm for $n<4$ single runs and the classical query-and-guess algorithm for $n<3$ single runs. However, unlike the classical algorithms it never converges to 100 \% success probability due to always-present unitary and non-unitary errors in our system. We will analyze various errors that are relevant to our experiment in the next section.

\section{Error Analysis}

There are three kind of errors arising in our implementation of the Grover search algorithm that we will analyze in the following section. These errors are:

\begin{enumerate}
	\item Deterministic, unitary gate errors
	\item Stochastic errors introduced due to qubit decoherence during the run time of the algorithm
	\item Readout errors due to qubit relaxation during readout, insufficient readout sensitivity or retrapping of the readout resonator state during measurement.
\end{enumerate}

\subsection{Gate Errors \& Decoherence}

Gate errors are unitary errors that arise due to misshaped or detuned gate pulses and qubit frequencies. Usually the effect of these errors is combined with stochastic, non-unitary errors arising due to qubit decoherence during the run time of the algorithm and therefore has to be analyzed together with the latter. Hence, in order to quantify these errors it is necessary to generate an error model of our algorithm that takes into account both unitary and non-unitary errors. The parameters of such a model can be obtained by numerically fitting it to our experimental results. 

\subsubsection{Modeling Decoherence}

In principle, to model decoherence processes in our algorithm, we could formulate an effective master equation of the two-qubit system that includes relaxation and dephasing processes, as we did when analyzing the universal quantum gate that we implemented. However, for our implementation of the Grover algorithm, we chose to rather use a set of discrete decoherence operators that model amplitude (i.e. $T_1$) and phase damping (i.e. $T_\phi$) processes and which we can directly integrate in a more simple, operator-based model of the algorithm. We can then model the decoherence by applying these operators to the calculated quantum states after each individual step of the algorithm. The resulting error model incorporates the most relevant experimental decoherence processes without the need to numerically integrate an effective master equation, thereby greatly speeding up the process of fitting our experimental data. In the following paragraphs we introduce the reader to the operators we use to model relaxation and dephasing processes in our error model.

\smallskip

To model qubit relaxation, we can use a pair of non-unitary single-qubit operators describing amplitude-damping of the qubit state, which given as \citep{nielsen_quantum_2000}
%
\begin{align}
 E_1^{T_1} & = \left(\begin{array}{cc} 1 & 0 \\ 0 & \sqrt{1-\gamma_{T_1}} \end{array}\right)   &  E_2^{T_1}  & = \left( \begin{array}{cc} 0 & \sqrt{\gamma_{T_1}} \\ 0 & 0 \end{array} \right) \label{eq:grover_energy_relaxation}
\end{align}
%
On the other hand, phase-damping operators describing qubit dephasing can be written analogously as
%
\begin{align}
 E_1^{T_{\phi 1}} & = \left(\begin{array}{cc} 1 & 0 \\ 0 & \sqrt{1-\gamma_\phi} \end{array}\right)   &  E_2^{T_{\phi 1}}  & = \left( \begin{array}{cc} 0 & 0 \\ 0 & \sqrt{\gamma_\phi}  \end{array} \right) \label{eq:grover_phase_decoherence}
\end{align}
%
Both operators are applied to a quantum state $\rho$ according to
%
\begin{equation}
\rho \to E_1 \rho E_1^\dagger+E_2 \rho E_2^\dagger
\end{equation}
%
and yield a trace-preserving, non-unitary evolution of the quantum state of $\rho$. The decoherence fraction $\gamma$ that is used in the operators can be calculated from the corresponding relaxation and dephasing rates as $\gamma_{T_{1,2}}(t) = 1-\exp{\left(-t \Gamma_{1,2}^{T_1}\right)}$ and $\gamma_{\phi_{1,2}} = 1-\exp{\left(-t \Gamma_{1,2}^{T_\phi}/2\right)}$, where $t$ is the time during which the state is exposed to the given decoherence process.

\smallskip

\begin{figure}[ht!]
	\centering
		\includegraphics[width=0.85\textwidth]{"./material/papers/grover/grover_error_model"}
	\caption[Error model used for analyzing gate and decoherence errors for the Grover search algorithm]{The error model we use to analyze the different gate and decoherence errors present when running the Grover search algorithm. The dotted lines indicate the points at which the quantum state has been measured by state tomography.}
	\label{fig:GroverErrorModel}
\end{figure}


Using these two operators combined with a set of unitary operators describing the quantum operations performed during the algorithm we formulate a full error model that we use to model our experimental data, as shown in fig. \ref{fig:GroverErrorModel}. This model takes into account the following error sources:

\begin{itemize}
 \item {\bf Energy relaxation and phase decoherence}: Energy relaxation and dephasing of the qubit is modeled using the processes given in eqs. (\ref{eq:grover_energy_relaxation}) and (\ref{eq:grover_phase_decoherence}), applying these operators with an adapted $\gamma$ after each unitary operation performed during the algorithm.
 \item {\bf Single-qubit gate errors}: We model rotation angle and rotation phase errors of our single-qubit $X_\alpha$ and $Y_\alpha$ gates by replacing them with operators of the form $X_\alpha\to \phi_{\alpha'} = \cos{\phi}X_{\alpha'}+\sin{\phi}Y_{\alpha'}$ and $Y_\alpha \to \varphi_{\alpha'} = \sin{\varphi}X_{\alpha'}+\cos{\varphi}Y_{\alpha'}$. For $Z$-type single-qubit operators we model only rotation angle errors by replacing $Z_\alpha \to Z_{\alpha'}$ 
 \item {\bf Two-qubit gate errors:} We model both detuning and gate-length errors of our $i\mathrm{SWAP}$ 2-qubit gates.
\end{itemize}

For the two-qubit gates, we model the errors present in the $i\mathrm{SWAP}$ operation by using the representation of the gate given by eq. (\ref{eq:swap_with_detuning}). We replace $t$ and $\Delta$ with $\epsilon = t g_{e}$ and $\delta = \Delta / g$. Using this notation of the iSWAP gate and the definition of the single-qubit gates as discussed before, the full algorithm with only gate errors can be written as (for right-multiplication)
%
\begin{equation}
\mathrm{Grover} = \phi_{\gamma_1}^1\otimes \phi_{\gamma_2}^2\cdot i\mathrm{SWAP}(\epsilon_2,\delta_2)\cdot Z_{\beta_1}\otimes Z_{\beta_2}\cdot i\mathrm{SWAP}(\epsilon_1,\delta_1)\cdot\varphi_{\alpha_1}^1\otimes \varphi_{\alpha_2}^2 \label{eq:grover_error_model}
\end{equation}
%
In addition, we add dephasing and relaxation error after each step of the algorithm to model the decoherence during the run time. Numerical optimization is then used to fit the error model to the experimentally obtained density matrices. The resulting fitting parameters are summarized in tab. \ref{tab:grover_error_parameters}. Here, the qubit relaxation and dephasing times were determined independently and are not part of the fit.

\begin{table}[ht!]
\centering
\footnotesize{
\begin{tabular}{r|rrrrrrrrrrrrrr}
state & $\delta_1$ & $\delta_2$ & $\alpha_1$ & $\alpha_2$ & $\varphi_1$ & $\varphi_2$ & $\epsilon_1$ & $\beta_1$ & $\beta_2$ & $\epsilon_2$ & $\gamma_1$ & $\gamma_2$ & $\phi_1$ & $\phi_2$ \\ \hline
$\ket{00}$ & 0.06 & -0.06 & -2.5 & 2.7 & 6.1 & 3.1 & -7.3 & -3.3 & -4.1 & 7.5 & 29 & 9.3 & 0.66 & -1.7
 \\
$\ket{01}$ & 0.04 & -0.3 & -0.1 & 0.1 & 7.9 & 3.6 & -11 & -5.9 & 2.2 & -6.9 & 28 & -19 &  9 &  2
 \\
$\ket{10}$ & 0.09 & -0.2 & -3.1 & 1.7 &  1 & -2.5 & -6.5 & -15 & -22 & -7.5 & -15 & 32 & 3.6 & 5.2
\\
$\ket{11}$ & 0.16 & 0.13 & -6 & 3.9 & 2.2 & 0.9 & -9.5 & -20 & -15 & 17 & -12 & -32 & -7 & -8.9
\end{tabular}
}
\caption[Fitted gate error parameters of the Grover algorithm]{Fitted error parameters for the measured density matrices, modeled according to the error model given in eq. (\ref{eq:grover_error_model}). All angles are given in $\deg$.}
\label{tab:grover_error_parameters}
\end{table}

The resulting fitted error models obtained for our experimental data are shown in tab. \ref{tab:grover_error_parameters}. As can bee seen, the phase and gate-time errors for the first gates are comparatively small and grow bigger during the following steps of the algorithm. Curiously, the phase errors are bigger for the states $\ket{10}$ and $\ket{11}$, as are the gate-length errors for the two $i\mathrm{SWAP}$ gates used in the algorithm. This fact might be explained by a drift of the operating point of our microwave setup during the time it took to take the data for the four possible Oracle operators and during which the parameters of individual qubit gates were not re-calibrated. Our error model is able to capture most of the observed experimental errors and can reproduce to very good accuracy the observed density matrices. The state fidelities according to eq. \ref{eq:quantum_state_fidelity} between the measured density matrices and those of the fitted error model are all $>95\%$.

\subsubsection{Fidelity of the Oracle and Diffusion Operators}

It is interesting to analyze the individual experimental fidelities of the Oracle and diffusion operators that make up the Grover algorithm. For this, we compare the action of the ideal operators $D$ and $R$ with that of the experimentally implemented versions $D_{e}$ and $R_{e}$, taking the measured quantum states before applying each of the operators as input. We then take as the fidelity of each operator the average state fidelity of the measured output states as compared to the calculated ones, i.e.
%
\begin{eqnarray}
F(D_{e}) & = & F(D\rho_{in}D^{\dagger},D_e \rho_{in} D_{e}^{\dagger}) \label{eq:grover_diffusion_fidelity} \\
F(R_{e}) & = & F(R\rho_{in}R^{\dagger},R_e \rho_{in} R_{e}^{\dagger}) \label{eq:grover_oracle_fidelity}
\end{eqnarray}
%
where we also make use of the state fidelity according to eq. \ref{eq:quantum_state_fidelity}. By this method, we obtain the following experimental fidelities for the two gate operations:

\begin{table}[ht!]
\centering
\begin{tabular}{r|rrrr|l}
Operator / State & $\ket{00}$ & $\ket{01}$ & $\ket{10}$ & $\ket{11}$ & Average \\ \hline 
$D$ & 92.3 & 93.4 & 94.3 & 91.7 & 92.9 \\
$R$ & 94.5 & 93.6 & 88.5 & 87.7 & 91.1
\end{tabular}
\caption[Measured fidelities of the quantum Oracle and diffusion operators used in the Grover search algorithm]{Measured fidelities of the quantum Oracle and diffusion operators used in the Grover search algorithm according to eqs. (\ref{eq:grover_diffusion_fidelity}) and (\ref{eq:grover_oracle_fidelity}). All fidelities are given in percent.}
\end{table}

As can be seen, on average we are able to implement both the diffusion operator and the quantum Oracle with a fidelity $>90\%$.
\subsection{Readout Errors}

\begin{SCfigure}[1.0][ht!]
	\centering
\includegraphics[width=0.5\textwidth]{"./data/ct5/2011_04_21 - grover and tomo/good_data/readout only"}
	\caption{The measured readout matrix for the Grover experiment. Shown are the conditional probabilities $p_m(x|y)$ of obtaining a readout value $x$ after having prepared a qubit state $\ket{y}$, where $x,y\in\{00,01,10,11\}$. The readout fidelities for the different qubit states range between 75 - 88 \%, the inter-qubit readout crosstalk ranges between 3-5 \%.}
	\label{fig:GroverReadoutMatrix}
\end{SCfigure}

Another source of errors affecting the single-run fidelities of the algorithm arises due to the imperfection of our qubit readout. Here, mostly qubit relaxation during the readout process reduces the visibility of individual qubit states and introduces errors when reading out the qubit register in the final step of the algorithm. We can easily quantify those readout errors by using the readout matrix that was introduced in chapter \ref{chapter:processor_characterization}. When running the Grover algorithm, we use the $\ket{1}\to\ket{2}$ shelving method described in chapter \ref{chapter:measurement} to increase the readout contrast and thereby the algorithm fidelity. This technique reduces single-qubit readout errors but increases inter-qubit readout crosstalk. The measured readout matrix for the Grover experiment is shown in fig. \ref{fig:GroverReadoutMatrix}. As can be seen, the single-qubit readout fidelities range between 87 - 96 \% and the combined two-qubit readout fidelities between 75 - 88 \%. Depending on the qubit state we also observe between 3-5 \% inter-qubit readout crosstalk.

\section{Conclusions}

We have shown that we can implement the Grover search algorithm with our quantum processor and achieve a single-run fidelity that is sufficient to demonstrate simple probabilistic quantum speed-up, as compared to a classical, reversible search algorithm. The error model formulated in this chapter is able to account for most of the observed imperfections and can explain the data we observed. Unfortunately, the coherence times of our qubits do not permit the realization of more complex algorithms with our processor, but nevertheless it provides a proof-of-principle of our approach to build a superconducting quantum computer with individual-qubit single shot readout.
